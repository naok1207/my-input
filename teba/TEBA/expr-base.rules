# 
# Copyright (c) 2009-2020 The TEBA Project. All rights reserved.
# 
# Redistribution and use in source, with or without modification, are
# permitted provided that the following conditions are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
# 
# Author: Atsuhi Yoshida

# Operator Precedence
# 01 left: (), [], ., ->, ++, --, ::
# 02 right: ++, --, sizeof, &, *, +, - ~, !, (cast), ::
# 03 left: *, /, %
# 04 left: +, -
# 05 left: <<, >>
# 06 left: <, <=, >, >=
# 07 left: ==, !=
# 08 left: &
# 09 left: ^
# 10 left: |
# 11 left: &&
# 12 left: ||
# 13 right: ?:
# 14 right: =, +=, -=, *=, /=, %=, <<=, >>=, &=, ^=, |=
# 15 left: ,

# Operator :: is for C++.

# terminal elements
@TERMINAL => "(?:ID_(?:VF|MB|MC)|LI[CN]).*+\n"
{ $id:TERMINAL } => { ''#1:_B_X $id ''#1:_E_X }
{ $id:ID_VFT } => { $id:ID_TP } # typedefed type

# The type name following '##' should be treat as variable.
{ $pj:PRE_JOIN $sp:SP $tp:ID_TP } => { $pj $sp ''#1:_B_X $tp ''#1:_E_X }

{ $bp:_B_X $[v1: $:/ID\w+/ $| $:PRE_JOIN $| $:SP $]+ $ep:_E_X $sp1:SP
  $pj:PRE_JOIN $sp2:SP $:_B_X $[v2: $:/ID\w+/ $| $:PRE_JOIN $| $:SP $]+ $:_E_X }
=>> { $bp $v1 $sp1 $pj $sp2 $v2 $ep}

# string literals generated by '#' operator in macro definitions.
{ $p:PRE_S $:_B_X $id:/ID_.*/ $:_E_X } => { ''#1:_B_X $p $id ''#1:_E_X}

# Parenthesis
{ $pl:P_L } => { '':_B_X $pl }
{ $pr:P_R } => { $pr '':_E_X }

# Compound literals (including initial expressions in declarators)
{ $bc:B_CP } => { '':_B_X  $bc }
{ $ec:E_CP } => { $ec '':_E_X }

@|BeginEnd->new()->conv|

# string literal concatenation
{ $str:LIS } => { ''#1:_B_S $str ''#1:_E_S }
{ $es:_E_S $sp:SP '(?>':X $bx#1:_B_X $id:/ID\w+|P_L|PRE_S/
  $expr:ANY $ex#1:_E_X ')':X }
  =>> { $sp $bx $id $expr $ex $es}
{ '(?>':X $bx#1:_B_X $id:/ID\w+|P_L|PRE_S/ $expr:ANY $ex#1:_E_X ')':X
  $sp:SP $bs:_B_S }
  =>> { $bs $bx $id $expr $ex $sp }
{ $e1#1:_E_S $sp:SP $b2#2:_B_S '(?>':X $str2:ANY $e2#2:_E_S ')':X }
  =>> { $sp $str2 $e1 }
{ $b:_B_S } => { $b:_B_X }
{ $e:_E_S } => { $e:_E_X }

# cast operators
{ $bc:B_CAST $:_B_X } => { $bc }
{ $:_E_X $ec:E_CAST } => { $ec }

# distinguishing binary and unary operators.

# binary operators
#@EXPR_END => "(?:ID_(?:VF|MB)|P_R).*+\n"
#@BINOP => "OP\s+<[-\+\*]>\n"
#{ $e:EXPR_END $sp:SP $op:BINOP }

# unary operators
@BORDER => "(?:[BE]_(?:[^D]|DE)|CA|[PA]_L|ID_TP|RE_(?:L|JP)|SC|C_L|OP).*+\n"
{ $b:BORDER $sp:SP $op:OP/(?:[-\+\*\&.]|::)/ } =>> { $b $sp $op:OP_U }
#@BORDER => "(?:[BE]_(?:[^D]|DE)|CA|[PA]_L|ID_TP|RE_(?:L|JP)|SC|C_L).*+\n"
#{ $[b: $:BORDER $| $:/OP(?:_[UT])?//.|.+=|&&|\|\||<<|>>|sizeof/ $] $sp:SP
#  $op:OP/(?:[-\+\*\&.]|::)/ } =>> { $b $sp $op:OP_U }
# SC is for the ones in for loops.
# There is a case that cannot be identified in this point.
# x++ *y: '*' is not unary.
# ++ *y:  '*' is unary.
# This rule treat '*' as unary. Instead, after '++' and '--' are identified
# it's type is changed to binary if need.
